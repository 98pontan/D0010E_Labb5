package lab5.main;
import java.util.Random;
import lab5.events.StartEvent;
import lab5.K;
import lab5.events.ClosingEvent;
import lab5.events.StopEvent;
import lab5.sim.*;
import lab5.store.StoreState;
import lab5.view.StoreView;

/**
 * This class is used to optimize the operations of a simulated environment.
 * It runs simulations to find the optimal amount of checkouts while the other parameters is set.
 * @author Markus Blomqvist.
 */
public class Optimize {
    public static void main(String[] args) {
        Optimize opt = new Optimize();
        long SEED = K.SEED;

        // testar
        System.out.println("Minsta antal kassor som ger minimalt antal missade kunder (" +
                opt.metod2(SEED) + "): " /*+ opt.metod3(SEED)*/);
    }

    public int metod1(long SEED, int CHECKOUTS, int MAX_CUSTOMERS,
                      double lowerGather, double upperGather, double ARRIVAL_SPEED,
                      double lowerRegister, double upperRegister,  double SIM_TIME){

        // Kanske ska skapa en SimState model istället? Kanske fråga om detta?
        // I lab5 dokumentet: "Viktigt är att den generella simulatorn inget vet om den specifika."
        // "Den ska fungera för vilken specifik simulator som helst, inte bara en snabbköpssimulator."
        StoreState model = new StoreState(
                SEED,
                CHECKOUTS,
                MAX_CUSTOMERS,
                ARRIVAL_SPEED,
                lowerGather, upperGather,
                lowerRegister, upperRegister);

//        StoreView view = new StoreView(model);
        EventQueue queue = new EventQueue();
        queue.addEvent(new StopEvent(model, queue));
        queue.addEvent(new ClosingEvent(model, queue, SIM_TIME));
        queue.addEvent(new StartEvent(model, queue));

        Simulator sim = new Simulator(model, queue);
        sim.run();

        return model.getMissedCustomers();
    }

    public int metod2(long SEED){
        // The first method's parameters.
        int MAX_CUSTOMERS = K.M;
        double SIM_TIME = K.END_TIME;
        double ARRIVAL_SPEED = K.L;
        double lowerGather = K.LOW_COLLECTION_TIME;
        double upperGather = K.HIGH_COLLECTION_TIME;
        double lowerRegister = K.LOW_PAYMENT_TIME;
        double upperRegister = K.HIGH_PAYMENT_TIME;

        // The minimal amount of checkouts can not be bigger than MAX_CUSTOMERS.
        int checkouts = MAX_CUSTOMERS;
        int missedCustomers = metod1(SEED, checkouts, MAX_CUSTOMERS,
              lowerGather, upperGather, ARRIVAL_SPEED,
              lowerRegister, upperRegister, SIM_TIME);
        int optimizedCheckouts = 0;
        
        while (checkouts >= 1)
        {
        	int newMissedCustomers = metod1(SEED, checkouts, MAX_CUSTOMERS,
                    lowerGather, upperGather, ARRIVAL_SPEED,
                    lowerRegister, upperRegister, SIM_TIME);
            System.out.println("INIT: "+missedCustomers+", NEW: "+newMissedCustomers);
        	
            if (missedCustomers == newMissedCustomers)
            {
            	optimizedCheckouts = newMissedCustomers;
            }
            
        	checkouts--;
        }
        return optimizedCheckouts;

//        // Initial value of missedCustomers.
//        int missedCustomers = metod1(SEED, minCheckouts, MAX_CUSTOMERS,
//                lowerGather, upperGather, ARRIVAL_SPEED,
//                lowerRegister, upperRegister, SIM_TIME);
//
//        // Gets a new value as long as minCheckouts >= 1.
//        while(minCheckouts >= 1){
//            // Creates a new amount of missed customers.
//            int newMissedCustomers = metod1(SEED, minCheckouts, MAX_CUSTOMERS,
//                    lowerGather, upperGather, ARRIVAL_SPEED,
//                    lowerRegister, upperRegister, SIM_TIME);
//
//            // Checks if NewMissedCustomers is different than the initial value.
//            // If it is different the last amount of checkouts was the most optimal amount.
//            if(missedCustomers < newMissedCustomers){
//                return minCheckouts + 1;
//            }
//
//            // Decreases the amount of minCheckouts.
//            minCheckouts--;
//        }
//        return minCheckouts;
    }

    public int metod3(long SEED){
        // Sets a random seed number.
        Random rand = new Random(SEED);
        int smallestAmountNeeded = 0;
        int counter = 0;

        // Runs 100 times if the maximum of the minimum number of checkouts has not changed.
        while(counter < 100){

           // Creates a new amount of checkouts by sending in a new random SEED into the second method.
           int newAmountOfCheckouts = metod2(rand.nextLong());

           // If true, the counter resets. If false then the counter counts up by 1.
           if(smallestAmountNeeded > Math.max(smallestAmountNeeded, newAmountOfCheckouts)){
              smallestAmountNeeded = newAmountOfCheckouts;
              counter = 0;
           }
           else{
              counter++;
           }
           smallestAmountNeeded = Math.max(smallestAmountNeeded, newAmountOfCheckouts);
        }

        return smallestAmountNeeded;
     }
}