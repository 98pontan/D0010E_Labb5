package lab5.store;
import java.util.ArrayList;

import lab5.sim.SimState;

public class StoreState extends SimState {
	private ArrayList<Customer> customers;
	private CreateCustomer customerFactory;
	private Time timeFactory;
	
	int checkOuts;
	int maxCheckouts;
	int maxCustomersToday;
	int missedCustomers;
	int availableCheckouts;
	int totQueueTime;
	int emptyCheckoutTime;
	int occupideCheckouts;
	final int MAXCUSTOMERS;
    int registers;
    int max_customers;
	
	public StoreState(long seed,
          int registers,
          int max_customers,
          double arrival_speed,
          double lowerGather, double upperGather,
          double lowerRegister, double upperRegister)
	{
		MAXCUSTOMERS = max_customers;
		checkOuts = registers;
//		availableCheckouts = openCheckout;
        timeFactory = new Time(this, seed, lowerRegister, upperRegister, lowerGather, upperGather, arrival_speed);
	}
	
	
	/**
	 * checks if a checkout is available 
	 * @return true if available false if occupied
	 */
	public boolean checkAvailbleCheckout() 
	{
		if(availableCheckouts > 0) 
		{
			return true;
		}
		
		return false;
	}
	
	/**
	 * If a checkout is being occupide by a customer
	 */
	void occupideCheckout() 
	{
		if(availableCheckouts > 0) 
		{
			availableCheckouts--;
			occupideCheckouts++;
			//time
		}
	
	}
	
	/**
	 * Makes a checkout available after a customer has used it. 
	 */
	void emptyCheckout()
	{
		if(availableCheckouts + 1 <= checkOuts)
		{
			availableCheckouts++;
			
			if(occupideCheckouts - 1 >= 0)
				occupideCheckouts--;
			//time
		}
	}
	
	/**
	 * Opens checkouts
	 * @param n, number of checkouts to open
	 */
	void openCheckout(int n) 
	{
		checkOuts += n;
		
		if(checkOuts > maxCheckouts)
			maxCheckouts = checkOuts;
			
	}
	
	/**
	 * Closes checkouts so long its positive
	 * @param n, number of checkout to close
	 */
	void closeCheckouts(int n) 
	{
		if(n - checkOuts >= 0) 
			checkOuts -= n;
	}
	
	/**
	 * Increases the number of missed customers if the number of customers is over the max number of customers. 
	 * @param
	 */
	void missedCustomers () 
	{
		if(customers.size() + 1 > MAXCUSTOMERS)
			missedCustomers++;
	}
	
	/**
	 * @return number of customers in the store
	 */
	int getCustomersInStore() 
	{
		int customersInStore = 0;
		for(int index = 0; index < customers.size(); index++)
		{
			if(customers.get(index).getState() == CustomerState.IN_STORE)
			{
				customersInStore += 1;
			}
		}
		return customersInStore;
	}
	
	/**
	 * @return number of open checkouts
	 */
	int getcheckOuts() 
	{
		return checkOuts;
	}
	
	
	/**
	 * @return number of available checkouts
	 */
	public int getAvailableCheckouts() 
	{
		return availableCheckouts;
	}
	
	/**
	 * @return number of occupied checkouts
	 */
	publc int getOccupideCheckouts() 
	{
		return occupideCheckouts;
	}
	
	/**
	 * @return number of customers visiting the store 
	 */
	int getMaxCustomersToday()
	{
		return maxCustomersToday;
	}
	
	/**
	 * @return number of customers missed due to a full store
	 */
	int getMissedCustomers() 
	{
		return missedCustomers;
	}
	
	/**
	 * @return the total time of queuing
	 */
	double gettotQueueTime()
	{
		return totQueueTime;
	}
	
	public void addCustomer(Customer customer)
	{
		if(!runFlag)
		{
			customer.setState(CustomerState.LATE_CUSTOMER);
		}
		else if(getCustomersInStore() < MAXCUSTOMERS)
		{
			customer.setState(CustomerState.IN_STORE);
		}else
		{
			customer.setState(CustomerState.TURNED_AWAY);
		}
		customers.add(customer);
	}
	
	/**
	 * Creates an new customer.
	 * @return new customer.
	 */
	public Customer createCustomer()
	{
		Customer customer = customerFactory.createCustomer();
		return customer;
	}
	
	public Time getTimeFactory()
	{
		return timeFactory;
	}

}
